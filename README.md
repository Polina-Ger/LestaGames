# Вопрос №1

## Реализация:

&nbsp;Для выполнения задания был написан алгоритм, определяющий значение последнего бита числа. Поскольку любое четное число оканчивается в побитовом представлении на 0, а нечетное на единицу, возможно проверить число на четность путем выяснения значения последнего бита числа. Для этого использовалось побитовое умножение (&), умножающее побитово полученное функцией число на битовое представление цифры 1, поскольку у данной цифры лишь последний бит представлен единицей, а все остальные являются нулями. При побитовом умножении каждый бит одного числа умножается на каждый бит другого, то есть 010100&011111=010100, поэтому если у числа последний бит будет равен 0 (число будет четным), то результат побитового умножения выведет цифру 0 (False), а если 1(число будет нечетным), то цифру 1 (True). Перевернув полученное значение в противоположную сторону для корректности вывода результата по заданным критериям работы функции, получим следующий результат:

```python
def isEven(value):
    return not(value&1)
```
&nbsp;Таким образом, при четности числа функция возвращает True, при нечетности False.

&nbsp;Плюсы и минусы реализаций:
&nbsp;Было проведено несколько тестов по замеру времени работы обеих функций в среде Visual Studio, результаты которых приведены в таблице:

| № теста | Изначальный алгоритм  | Написанный алгоритм      |
| :---    |     :---:             |                ---:      |
| 1       | 0.19409560000349302 с | 0.17820170000049984 с    |
| 2       | 0.19435140000132378 с |  0.23447890000534244 с   |
| 3       | 0.1690466000000015 с  | 0.1485058000034769 с     |
| 4       | 0.15285640000365674 с | 0.1927235000039218 с     |

&nbsp;Из таблицы видно, что написанный алгоритм пи разных запусках работает либо чуть быстрее изначального, либо чуть медленней, поэтому выделить конкретный способ по скорости довольно трудно. Однако стоит отметить, что изначальный алгоритм является более понятным для написания с точки зрения математики.

# Вопрос №2

## Реализация:

&nbsp;Для выполнения задания были выбраны два варианта реализации циклического буфера FIFO:
* Реализация с помощью массива(list)
* Реализация с помощью двусвязного списка

&nbsp;Реализация при помощи массива предполагает создание объекта типа list с фиксированной длиной, указывающейся при определении класса. При добавлении или изъятии элементов из такого объекта его размерность не меняется, меняются лишь указатели на первый и последний элемент в циклической очереди.
&nbsp;Реализация первого варианта циклической очереди:

```python
class cyclic_buffer:
    def __init__(self, capacity):
        if capacity<1: raise ValueError("Capacity must be more than 1!")
        self.arr=[None]*capacity
        self.capacity=capacity
        self.first=0
        self.last=0
        self.size=0

    def is_full(self):
        return self.size==self.capacity
    def is_empty(self):
        return self.size==0

    def put(self, value):
        self.arr[self.last]=value
        self.last += 1
        if self.last == self.capacity:
            self.last = 0
        if self.is_full():
            self.first += 1
            if self.first == self.capacity:
                self.first = 0
        else:self.size+=1
    
    def get(self):
        if self.is_empty():
            print("Array is empty!")
            return
        taken_value=self.arr[self.first]
        self.first += 1
        if self.first == self.capacity:
            self.first = 0
        self.size-=1
        return taken_value

    def print_arr(self):
        arr = [None]*self.capacity
        for i in range(self.capacity):
            arr[i]=self.arr[self.first]
            self.first += 1
            if self.first == self.capacity:
                self.first = 0
        print(arr)
```
&nbsp;Второй вариант реализации предполагает создание отдельных элементов класса Node(), содержащих в себе указатели на предыдущий элемент того же класса и на следующий, а также значение элемента. Таким образом, возможно быстро получить доступ к первому, либо к последнему элементу двусвязного списка, что может значительно ускорить работу программы. При добавлении или извлечении элемента из циклической очереди при тако реализации изменяются лишь ссылки на элементы класса Node().
&nbsp;Реализация второго варианта циклической очереди:

```python
class Node:
    def __init__(self, value=None):
        self.value=value
        self.next=0
        self.previous=0
class cyclic_buffer_doubleList:
    def __init__(self, capacity):
        if capacity<1: raise ValueError("Capacity must be more than 1!")
        self.capacity=capacity
        self.first=0
        self.last=0
        self.size=0
        self.create_nodes()

    def create_nodes(self):
        firstNode=Node()
        prev=firstNode
        for i in range(self.capacity-1):
            node=Node()
            prev.next=node
            node.previous=prev
            prev=node
        firstNode.previous=prev
        prev.next=firstNode
        self.first=firstNode
        self.last=firstNode


    def is_full(self):
        return self.size==self.capacity
    def is_empty(self):
        return self.size==0

    def put(self, value):
        self.last.value=value
        self.last=self.last.next
        if self.is_full():
            self.first=self.first.next
        else:self.size+=1
    
    def get(self):
        if self.is_empty():
            print("List is empty!")
            return
        taken_value=self.first.value
        self.first=self.first.next
        self.size-=1
        return taken_value

    def print_arr(self):
        arr = [None]*self.capacity
        for i in range(self.capacity):
            arr[i]=self.first.value
            self.first=self.first.next
        print(arr)
```
&nbsp;При сравнении скорости работы обоих вариантов реализации было установлено, что второй вариант работает быстрее первого, что может быть связано с наличием постоянных неизменяющихся ссылок на объекты класса Node(), что способствует отличной предсказуемости для процессора. Также данное различие может быть связано с тем, что в экземпляре двусвязного списка значение заменяется посредством изменения параметра класса, а в варианте с массивом механизм автоматического управления памятью языка Python может проводить проверки корректного выделения и высвобождения памяти, что также замедляет процесс. Кроме того, в варианте с двумерным массивом создается меньше временных объектов, чем в варианте с массивом, что также может давать преимущество в десятки наносекунд.
&nbsp;Результаты измерения быстродействия обоих вариантов реализации с помощью функции time представлены в таблице:

| № теста | Вариант с list | Вариант с двумерным массивом |
| :---    |     :---:      |                         ---: |
| 1       | 75.09 мс       | 63.15 мс                     |
| 2       | 82.14 мс       | 42.95 мс                     |
| 3       | 58.20 мс       | 39.06 мс                     |
| 4       |68.15 мс        | 50.41 мс                     |


# Вопрос №3

## Реализация:

&nbsp;В качестве реализации алгоритма сортировки массива была написана функция, сравнивающая элементы и меняющая их местами:

```python
def sorting (arr):
    length=len(arr)
    for i in range(length-1):
        index_min=i
        for j in range(i+1, length):
            if arr[index_min]>arr[j]:
                index_min=j
        if index_min!=i:
            arr[i],arr[index_min]=arr[index_min],arr[i]
```
&nbsp;В данном коде посредством двух циклов for один элемент сравнивается с каждым последующим, а затем текущий меняется со следующим местами, если следующий элемент больше текущего. Для быстроты выполнения кода результат подсчета длины массива был присвоен переменной length, а также сами преобразования происходят в массиве напрямую, без возвращения значения в стороннюю переменную.
&nbsp;Для проведения исследования на быстродействие также была реализована версия быстрой сортировки(quicksort), принципами работы которой является разделение массива на две части посредством опорной точки(pivot), а затем рекурсивная сортировка каждой из частей, после чего все части объединяются в один общий массив:

```python
def quicksort(arr):
    if len(arr)<=1:return arr
    left=[]
    right=[]
    middle=[]
    pivot = arr[len(arr)//2]
    for i in range(len(arr)):
        if arr[i]<pivot:
            left.append(arr[i])
        elif arr[i]>pivot:
            right.append(arr[i])
        else: middle.append(arr[i])
    return quicksort(left)+middle+quicksort(right)
```
&nbsp;Данный вариант сортировки удобен для больших массивов, а также массивов с одинаковыми числами, однако для маленьких массивов более быстрым является первый вариант алгоритма. Результаты проверок на быстродействие посредством функции timeit представлены в таблице:

| Название теста                             | Первый алгорит         | Второй алгоритм         |
| :---                                       |     :---:              |                    ---: |
| Маленький массив с разными числами         | 1.4196365000025253 с   | 2.0258604000046034 с    |
| Маленький массив с одинаковыми числами     | 1.4113278000004357 с   | 1.2213954999970156 с    |
| Маленький отсортированный массив           | 8.343139899996459 с    | 9.073282699995616 с     |
| Маленький частично отсортированный массив  |2.3457280000002356 с    | 3.9967284000013024 с    |
| Большой массив со случайными числами       |258.69891479999933 с    | 73.03126390000398 с     |


 Можно сделать вывод, что каждый вариант сортировки идеально подойдет для разных задач, все зависит от количества элементов и порядка их расположения.
